구조체 / 클래스 메모리 구조
생성자 / 소멸자

생성자 : 부모 ==> 자식
소멸자 : 자식 ==> 부모

        이것에 따라 결과 값이 다르게 나온다

//class7.cpp

Test() { // 생성자

}
~Test() { // 소멸자 => 메모리 제거

}

복사 (생성자) --> c에서 파생

생성자 
    인수가 함수의 매개변수를 던질 때

int a(int b) {

}



int main(void) {
    a(1); // b 값에 복사해준다 라고 한다 --> 대입한다 (X)
}

CTest t1(t); //t의 객체를 복사후 만들어진다 --> 복사 생성자에 의해 생성
	CTest t2 = t; // t의 객체를 복사후 만들어진다 --> "
	CTest t3; t3 = t; 만든 후 t를 복사한다 --> 생성자에 의해 생성 
                                           후 t의 값 복사


객체가 다른 객체로부터 복사 생성이 되는 경우 복사 생성자가 호출되고,
대입될 경우에는 복사 대입 연산자가 호출된다는 사실이다.


복사 생성자는 생성자의 중복 정의이다

    ClassName(const ClassName& obj) {

    }


복사 생성자 : 다른 객체와 똑같은 객체를 생성할 때 사용한다.
        class Cell {
            public:
            Cell(const Cell& obj);
        }
        생성자 안에서 원본 객체에 있는 데이터 멤버를 모두 복사해서 
        사용 가능하다.

        Cell::Cell(const Cell& obj)
            :mValue(obj.mValue) {

            }

함수에 객체를 값으로 전달하거나 함수가 객체를 값으로 반환할 때 객체는 
암묵적으로 복사된다

vector<int> vi;
double d;
d = median(vi); //vi를 median함수의 매개변수로 복사

string line;
vector<string words = split(line);

vector<Student_info> vs;
vector<Student_info> v2 = vs;



int a = 3;

b = a;

Cell::Cell(const Cell& obj)
            :mValue(obj.mValue) {
의 const값인 이유:
    객체 복사(복사된 객체)가 기존의 객체를 바꿔서는 안되므로 복사할 객체를 
    const 참조 타입으로 복사 생성자에게 전달


객체(=변수)는 정의되면 그 객체를 다른 객체에게 대입될 수 있다
           정의되면 그 객체를 다른 객체에게 그 객체가 가지고 있는 멤버들을
           대입할 수 있다.
           정의되면 그 객체를 다른 객체에게 자신이 가지고 있는 멤버들을
           복사하여 전달한다.

변수는 정의되면 그 변수를 다른 변수에게 대입될 수 있다
     정의되면 그 변수를 다른 변수에게 그 객체가 가지고 있는 값들을
     대입할 수 있다.
     정의되면 그 변수를 다른 변수에게 자신이 가지고 있는 값들을
     복사하여 전달한다.


     변수 : 데이터 가지고 있다

변수의 타입이 클래스인 경우 방식이 다르게 변한다.
    초기화 방식에 따라서 동작이 달라진다는 의미



객체 ==> 생성자

객체를 객체1에 대입 ==> 객체에서 복사된 생성자에 의해서 만들어야한다


CTest(const CTest& obj) {

}

복사 생성자
        암시적 / 묵시적

        생성자 선언이 안되어 있다면 컴파일러는 암시적으로 기본 생성자를
        정의하고 그에 따라서 기본적으로 복사 생성자도 암시적으로 디폴트 복사
        생성자를 정의한다.

//class8.cpp

복사 생성을 할 수 없다. const 객체로 부터 복사 생성을 할 수 없다.

//class9.cpp

초기화 순서

부모 class의 복사 생성자 먼저 호출

//class10.cpp

